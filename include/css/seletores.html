
<h2>A > B</h2>
Este seletor aplica o estilo somente aos filhos diretos de A, ao contrário do mais famoso A B, que seleciona todos os níveis de filhos de A. Este seletor é recomendado quando você deseja criar um estilo apenas para o primeiro nível dos filhos de um determinado elemento.
<pre>
ul > li {
   font-weight: bold;
}
</pre>

<h2>X + Y</h2>
Esse é chamado de seletor adjacente. Ele selecionará somente o elemento imediatamente após o primeiro elemento. No exemplo acima, selecionará só o primeiro parágrado após cada ul na página, e fará que ele tenha a cor vermelha.
<pre>
ul + p {
 color: red;
}
</pre>

<h2>X ~ Y</h2>
O seletor de irmão é parecido com o seletor X + Y, contudo, é menos restritivo. Enquanto o seletor adjacente (ul + p) só selecionará o primeiro elemento, imediatamente, após o elemento inicial, esse é mais generalista. Ele selecionará, usando o nosso exemplo acima, qualquer elemento p, desde que ele venha depois de um elemento ul. 
<pre>
ul ~ p {
 color: red;
}
</pre>

<h2>X[title]</h2>
<pre>
a[title] {
	color: green;
}
</pre>
Chamado de seletor de atributos, no nosso exemplo acima, ele só selecionará aquelas âncoras com um atributo title. As âncoras que não tiverem esse atributo, não receberão esse estilo em particular. Mas, e se precisarmos ser mais específicos? Bem...

<h2>X:checked</h2>
<pre>
input[type=radio]:checked {
	border: 1px solid black;
}
</pre>
Essa pseudo-classe somente selecionará o elemento da interface que foi marcado como selecionado – como um botão radio ou checkbox. Simples assim.

<h2>X:after</h2>
As pseudo-classes before e after são muito boas. Parece que, todos os dias, o pessoal encontra maneiras criativas e efetivas de usá-las. Elas, simplesmente, geram conteúdo ao redor do elemento selecionado.
Vários aprenderam sobre eles quando foram encontrar o hack do ajuste dos floats (alguns conhecem como clear-fix hack).
<pre>
.clearfix:after {
  content: "";
  display: block;
  clear: both;
  visibility: hidden;
  font-size: 0;
  height: 0;
  }
 
.clearfix {
 *display: inline-block;
 _height: 1%;
}
</pre>
Esse hack usa a pseudo-classe :after para adicionar um espaço após o elemento e, então, limpa-lo. É um ótimo truque para se ter em seu cinto de utilidades, principalmente quando a técnica do overflow: hidden; não é possível ser utilizada.

<h2>X:not(selector)</h2>
<pre>
div:not(#container) {
 color: blue;
}
</pre>
A pseudo-classe negação é, particularmente, útil. Digamos que você queira selecionar todas as divs, exceto por aquelas que contenham um identificador nomeado de container. O trecho acima lida com essa tarefa, perfeitamente.
Ou, se eu quisesse selecionar todos os elementos (o que não é recomendado), exceto pelas tags de parágrafo, poderíamos fazer assim:
<pre>
*:not(p) {
	color: green;
}
</pre>

<h2>X::pseudoElemento</h2>
<pre>
p::first-line {
	font-weight: bold;
	font-size: 1.2em;
}
</pre>
Nós podemos usar pseudo-elementos (designados por ::) para estilizar fragmentos de um elemento, como a primeira linha ou uma primeira letra. Lembre-se que essa regra precisa ser aplicada a elementos do tipo bloco para surtirem efeito.
<h2>Um pseudo-elemento é composto por dois "dois pontos": ::</h2>
Selecione a Primeira Letra de um Paraágrafo
<pre>
p::first-letter {
 float: left;
 font-size: 2em;
 font-weight: bold;
 font-family: cursive;
 padding-right: 2px;
}
</pre>


<h2>A:first-child / A:last-child</h2>
<pre>
ul li:first-child {  
   font-weight: bold;  
}     
ul li:last-child {  
   font-weight: bold;
}
</pre>


<h2>X:nth-child(n)</h2>
Você se lembra quando tinha de indicar um elemento específico de um conjunto de elementos? a pseudo-classe nth-child acaba com esse problema!
<br/>
Atente que o nth-child aceita um número inteiro como parâmetro, entretanto, a contagem não inicia em zero (como nas arrays e strings em programação). Se você deseja selecionar o segundo item de uma lista, faça assim li:nth-child(2).
<br/>
Nós podemos, até mesmo, selecionar um número variável de elementos filhos. Por exemplo, nós podemos fazer algo como li:nth-child(4n), para selecionar todos os itens que estejam em uma posição que seja múltipla de quatro. 

<pre>li:nth-child(3) {
 color: red;
}</pre>
<a href="http://codigofonte.uol.com.br/artigos/10-seletores-de-css-que-voce-deveria-usar">codigofonte</a>
<a href="https://code.tutsplus.com/pt/tutorials/the-30-css-selectors-you-must-memorize--net-16048">tutsplus</a>

<h2>regras par e ímpar </h2>
<h2>nth-child</h2>
Impares
<pre>#tabelaGrid tbody tr:nth-child(2n+1) {background: #ccc}</pre>
Pares
<pre>#tabelaGrid tbody tr:nth-child(2n) {background: #c1c1c1}</pre>
<a href="https://developer.mozilla.org/pt-BR/docs/Web/CSS/:nth-child">developer.mozilla</a> 
<a href="https://www.w3.org/Style/Examples/007/evenodd.pt_BR.html">w3</a>

