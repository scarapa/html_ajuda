<pre>async calcular(){
	const valor: number = 100;
	let valorCorrigido: number = 0;
	try {
		valorCorrigido = await this.calcularJuros(valor);
		valorCorrigido = await this.calcularMulta(valorCorrigido);
	}catch(error){
		console.log(valorCorrigido)
	}
} 

calcularJuros(valorBase:number):Promise&lt;number&gt;{
	return new Promise((resolve,reject) =&gt; {
		if(valorBase > 0){
			let result: number = 0;
			let juros: number = 0.1;

			result = valorBase + (valorBase * juros);
			resolve(result)
		}else{
			reject('o valor nao pode ser calculado')
		}
	});
}

calcularMulta(valorBase:number):Promise&lt;number&gt;{
	return new Promise((resolve,reject) =&gt; {
		if(valorBase > 0){
			let result: number = 0;
			let multa: number = 5;

			result = valorBase + multa;
			resolve(result)
		}else{
			reject('o valor nao pode ser calculado')
		}
	});
}</pre>

<h2>promise.all</h2>
O método <b>Promise.all(iterable)</b> retorna uma única Promise que resolve quando todas as promises no argumento iterável forem resolvidas ou quando o iterável passado como argumento não contém promises. É rejeitado com o motivo da primeira promise que foi rejeitada.
<pre>const promise1 = Promise.resolve(3);
const promise2 = 42;
const promise3 = new Promise(function(resolve, reject) {
  setTimeout(resolve, 100, 'foo');
});

Promise.all([promise1, promise2, promise3]).then(function(values) {
  console.log(values);
});</pre>
<code>retorno</code>
<pre>// expected output: Array [3, 42, "foo"]</pre>

<h2>promise.race</h2>
<pre></pre>